import Peer from 'peerjs';
import { CryptoHelper } from './crypto';
import { DeviceHelper } from './device';

export class P2PManager {
  constructor() {
    this.peer = null;
    this.connections = new Map();
    this.publicKey = null;
    this.privateKey = null;
    this.peerId = null;
    this.username = null;
    this.deviceInfo = null;
    this.roomCode = null;
    this.onMessageCallback = null;
    this.onConnectionCallback = null;
    this.onDisconnectionCallback = null;
    this.onStatusCallback = null;
    this.onIncomingPeerCallback = null; // Yeni: Gelen peer bildirimi
    this.onRoomJoinCallback = null; // Yeni: Oda katƒ±lƒ±m bildirimi
  }

  // P2P baƒülantƒ±yƒ± ba≈ülat
  async initialize(userId = null, username = null) {
    this.username = username;
    this.deviceInfo = DeviceHelper.getDeviceInfo();
    
    console.log('üñ•Ô∏è Cihaz bilgisi:', {
      type: this.deviceInfo.deviceType,
      os: this.deviceInfo.os,
      browser: this.deviceInfo.browser,
      name: DeviceHelper.getDeviceName()
    });
    
    try {
      // Anahtarlarƒ± √ºret
      const keyPair = await CryptoHelper.generateKeyPair();
      this.publicKey = keyPair.publicKey;
      this.privateKey = keyPair.privateKey;

      // PeerJS baƒülantƒ±sƒ±nƒ± ba≈ülat - Cloud sunucu kullan
      const config = {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
          ]
        },
        debug: 0 // Debug kapalƒ± - console temiz
      };

      this.peer = userId ? new Peer(userId, config) : new Peer(config);

      return new Promise((resolve, reject) => {
        // 30 saniye timeout (mobil cihazlar i√ßin)
        const timeout = setTimeout(() => {
          reject(new Error('Baƒülantƒ± zaman a≈üƒ±mƒ±na uƒüradƒ±. L√ºtfen tekrar deneyin.'));
        }, 30000);

        this.peer.on('open', (id) => {
          clearTimeout(timeout);
          this.peerId = id;
          console.log('‚úÖ Baƒülandƒ±:', id);
          this.onStatusCallback?.('connected', id);
          resolve(id);
        });

        this.peer.on('connection', (conn) => {
          this.setupConnection(conn);
        });

        this.peer.on('error', (err) => {
          clearTimeout(timeout);
          // Yaygƒ±n hatalarƒ± daha soft g√∂ster
          if (err.type === 'peer-unavailable') {
            // Sessizce handle et
          } else if (err.type === 'network' || err.type === 'server-error') {
            // Otomatik reconnect olacak
            this.onStatusCallback?.('reconnecting');
          } else {
            console.log('‚ö†Ô∏è Baƒülantƒ± sorunu (d√ºzeliyor...)');
            this.onStatusCallback?.('error', err.message);
          }
          
          // Sadece initialization hatalarƒ±nda reject et
          if (!this.peerId) {
            reject(err);
          }
        });

        this.peer.on('disconnected', () => {
          // Sessizce reconnect
          this.onStatusCallback?.('reconnecting');
          
          // 2 saniye sonra yeniden baƒülan
          setTimeout(() => {
            if (this.peer && !this.peer.destroyed) {
              this.peer.reconnect();
            }
          }, 2000);
        });

        this.peer.on('close', () => {
          // Sessizce handle et
          this.onStatusCallback?.('disconnected');
        });
      });
    } catch (error) {
      console.error('Initialization error:', error);
      throw error;
    }
  }

  // Ba≈üka bir peer'a baƒülan
  async connectToPeer(peerId) {
    if (this.connections.has(peerId)) {
      console.log('Already connected to', peerId);
      return;
    }

    if (!this.peer) {
      console.error('‚ùå Peer hen√ºz ba≈ülatƒ±lmadƒ±');
      return;
    }

    try {
      const conn = this.peer.connect(peerId, {
        reliable: true
      });

      if (!conn) {
        console.error('‚ùå Baƒülantƒ± olu≈üturulamadƒ±:', peerId);
        return;
      }

      this.setupConnection(conn);
    } catch (error) {
      console.error('‚ùå connectToPeer hatasƒ±:', error);
    }
  }

  // Baƒülantƒ±yƒ± yapƒ±landƒ±r
  setupConnection(conn) {
    conn.on('open', async () => {
      // Sessizce baƒülan
      this.connections.set(conn.peer, conn);

      // Public key'i, cihaz bilgisini ve oda kodunu payla≈ü
      const publicKeyData = await CryptoHelper.exportPublicKey(this.publicKey);
      conn.send({
        type: 'public-key',
        publicKey: publicKeyData,
        peerId: this.peerId,
        username: this.username || 'Unknown',
        deviceInfo: this.deviceInfo,
        deviceName: DeviceHelper.getDeviceName(),
        roomCode: this.roomCode
      });
      conn.sentPublicKey = true; // Public key g√∂nderildi i≈üaretle

      this.onConnectionCallback?.({
        peerId: conn.peer,
        connected: true,
        username: conn.metadata?.username
      });
    });

    conn.on('data', async (data) => {
      await this.handleData(conn.peer, data);
    });

    conn.on('close', () => {
      // Sessizce handle et
      this.connections.delete(conn.peer);
      this.onDisconnectionCallback?.(conn.peer);
    });

    conn.on('error', (err) => {
      // Sessizce handle et
    });
  }

  // Gelen veriyi i≈üle
  async handleData(peerId, data) {
    switch (data.type) {
      case 'room-join':
        // Ba≈üka bir peer odaya katƒ±ldƒ± - bilgisini kaydet
        console.log('üì• Oda katƒ±lƒ±m bildirimi alƒ±ndƒ±:', data.roomCode, 'from:', data.username);
        if (this.onRoomJoinCallback) {
          this.onRoomJoinCallback({
            roomCode: data.roomCode,
            roomInfo: data.roomInfo,
            peerId: data.peerId,
            username: data.username
          });
        }
        break;
      
      case 'public-key':
        // Kar≈üƒ± tarafƒ±n public key'ini sakla
        const publicKey = await CryptoHelper.importPublicKey(data.publicKey);
        const conn = this.connections.get(peerId);
        if (conn) {
          conn.publicKey = publicKey;
          conn.peerName = data.peerId;
          conn.username = data.username;
          conn.deviceInfo = data.deviceInfo;
          conn.deviceName = data.deviceName;
          conn.roomCode = data.roomCode;
          
          // Oda kodu kontrol√º - sessizce yap
          
          // Eƒüer biz de hen√ºz public key g√∂ndermediyse, g√∂nder
          if (!conn.sentPublicKey) {
            const myPublicKeyData = await CryptoHelper.exportPublicKey(this.publicKey);
            conn.send({
              type: 'public-key',
              publicKey: myPublicKeyData,
              peerId: this.peerId,
              username: this.username || 'Unknown',
              deviceInfo: this.deviceInfo,
              deviceName: DeviceHelper.getDeviceName(),
              roomCode: this.roomCode
            });
            conn.sentPublicKey = true;
          }
        }
        
        // Yeni peer geldiƒüini bildir (otomatik ekleme i√ßin)
        this.onIncomingPeerCallback?.({
          peerId: data.peerId,
          username: data.username || 'Unknown User',
          deviceInfo: data.deviceInfo,
          deviceName: data.deviceName,
          roomCode: data.roomCode,
          isOwnDevice: data.username === this.username, // Kendi cihazƒ±mƒ±z mƒ±?
          isSameRoom: this.roomCode && data.roomCode && this.roomCode === data.roomCode // Aynƒ± odada mƒ±?
        });
        break;

      case 'message':
        // ≈ûifreli mesajƒ± √ß√∂z
        console.log('üì® ≈ûifreli mesaj alƒ±ndƒ±:', peerId);
        try {
          console.log('üîì Mesaj ≈üifresi √ß√∂z√ºl√ºyor...');
          const decryptedMessage = await CryptoHelper.decrypt(
            this.privateKey,
            data.encrypted
          );
          console.log('‚úÖ Mesaj ≈üifresi √ß√∂z√ºld√º:', decryptedMessage);
          
          this.onMessageCallback?.({
            from: peerId,
            message: decryptedMessage,
            timestamp: data.timestamp,
            encrypted: true
          });
          console.log('‚úÖ Mesaj callback\'e iletildi');
        } catch (error) {
          console.error('‚ùå ≈ûifre √ß√∂zme hatasƒ±:', error);
        }
        break;

      case 'typing':
        this.onMessageCallback?.({
          from: peerId,
          type: 'typing',
          typing: data.typing
        });
        break;
    }
  }

  // Mesaj g√∂nder
  async sendMessage(peerId, message) {
    const conn = this.connections.get(peerId);
    if (!conn || !conn.publicKey) {
      throw new Error('Peer not connected or public key not available');
    }

    // Mesajƒ± ≈üifrele
    const encryptedMessage = await CryptoHelper.encrypt(message, conn.publicKey);
    
    conn.send({
      type: 'message',
      message: encryptedMessage,
      from: this.peerId,
      timestamp: Date.now()
    });
  }

  // Oda bilgisi BROADCAST et (t√ºm baƒülƒ± peer'lere)
  broadcastRoomJoin(roomCode, roomInfo) {
    console.log('üì¢ Oda katƒ±lƒ±m broadcast ediliyor:', roomCode);
    this.connections.forEach((conn, peerId) => {
      try {
        conn.send({
          type: 'room-join',
          roomCode: roomCode,
          roomInfo: roomInfo,
          peerId: this.peerId,
          username: this.username
        });
        console.log('‚úÖ Broadcast g√∂nderildi:', peerId);
      } catch (error) {
        console.warn('‚ö†Ô∏è Broadcast g√∂nderilemedi:', peerId);
      }
    });
  }

  // Yazƒ±yor durumunu g√∂nder
  sendTyping(peerId, isTyping) {
    const conn = this.connections.get(peerId);
    if (conn) {
      conn.send({
        type: 'typing',
        typing: isTyping
      });
    }
  }

  // Oda kodunu ayarla
  setRoomCode(roomCode) {
    this.roomCode = roomCode;
    console.log('üö™ Oda kodu ayarlandƒ±:', roomCode);
    localStorage.setItem('activeRoomCode', roomCode);
  }

  // Oda kodunu temizle
  clearRoomCode() {
    this.roomCode = null;
    localStorage.removeItem('activeRoomCode');
    console.log('üö™ Odadan √ßƒ±kƒ±ldƒ±');
  }

  // Baƒülantƒ±yƒ± kes
  disconnect(peerId) {
    const conn = this.connections.get(peerId);
    if (conn) {
      conn.close();
      this.connections.delete(peerId);
    }
  }

  // T√ºm baƒülantƒ±larƒ± kes
  disconnectAll() {
    this.connections.forEach((conn) => {
      conn.close();
    });
    this.connections.clear();
  }

  // Peer'ƒ± kapat
  destroy() {
    this.disconnectAll();
    if (this.peer) {
      this.peer.destroy();
    }
  }

  // Event listener'larƒ± ayarla
  onMessage(callback) {
    this.onMessageCallback = callback;
  }

  onConnection(callback) {
    this.onConnectionCallback = callback;
  }

  onDisconnection(callback) {
    this.onDisconnectionCallback = callback;
  }

  onStatus(callback) {
    this.onStatusCallback = callback;
  }

  // Aktif baƒülantƒ±larƒ± al
  getActiveConnections() {
    return Array.from(this.connections.keys());
  }

  // Baƒülantƒ± durumunu kontrol et
  isConnectedTo(peerId) {
    return this.connections.has(peerId);
  }
}
